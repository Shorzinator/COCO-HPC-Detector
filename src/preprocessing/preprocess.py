import os

import numpy as np
from PIL import Image
from pycocotools.coco import COCO
from scipy.ndimage import binary_dilation, binary_erosion, gaussian_filter
from tensorflow import keras

from src.utility.path_utils import get_path_from_root

# Constants
ANNOTATION_FILE_TRAIN = get_path_from_root('path/to/instances_train2014.json')
ANNOTATION_FILE_VAL = get_path_from_root('path/to/instances_val2014.json')
IMAGE_DIR = get_path_from_root('path/to/images')
MASK_DIR_TRAIN = get_path_from_root('path/to/mask_train_2014')
MASK_DIR_VAL = get_path_from_root('path/to/mask_val_2014')
TARGET_SIZE = (128, 128)  # Example target size for resizing images and masks

# Initialize COCO API
coco_train = COCO(ANNOTATION_FILE_TRAIN)
coco_val = COCO(ANNOTATION_FILE_VAL)


# Function to filter and load image IDs based on categories
def filter_images(coco, category_names):
    catIds = coco.getCatIds(catNms=category_names)
    imgIds = coco.getImgIds(catIds=catIds)
    return imgIds


# Function to generate and save masks
def generate_masks(coco, imgIds, mask_dir, image_dir, category_names):
    for img_id in imgIds:
        annIds = coco.getAnnIds(imgIds=img_id, catIds=coco.getCatIds(catNms=category_names), iscrowd=0)
        anns = coco.loadAnns(annIds)
        if anns:
            mask = np.zeros((coco.loadImgs(img_id)[0]['height'], coco.loadImgs(img_id)[0]['width']), dtype=np.uint8)
            for ann in anns:
                mask = mask | coco.annToMask(ann)
            mask_img = Image.fromarray(mask * 255, mode='L')
            mask_img.save(os.path.join(mask_dir, f"COCO_{coco.dataset['images'][img_id]['file_name']}"))

            # Process and save the corresponding image
            img_info = coco.loadImgs(img_id)[0]
            img_path = os.path.join(image_dir, img_info['file_name'])
            image = Image.open(img_path)
            resized_image = image.resize(TARGET_SIZE)
            resized_image.save(os.path.join(image_dir, img_info['file_name']))  # Saving resized image


# Function to apply transformations to masks
def transform_mask(mask):
    eroded_mask = binary_erosion(mask)
    dilated_mask = binary_dilation(mask)
    smoothed_mask = gaussian_filter(mask, sigma=0.2)
    return eroded_mask, dilated_mask, smoothed_mask


# Custom Data Generator for on-the-fly processing
class CustomDataGenerator(keras.utils.Sequence):
    def __init__(self, coco, imgIds, images_path, batch_size):
        self.coco = coco
        self.imgIds = imgIds  # List of image IDs to use
        self.images_path = images_path
        self.batch_size = batch_size

    def __len__(self):
        return int(np.ceil(len(self.imgIds) / self.batch_size))

    def __getitem__(self, idx):
        batch_imgIds = self.imgIds[idx * self.batch_size:(idx + 1) * self.batch_size]
        batch_images = []
        batch_masks = []

        for img_id in batch_imgIds:
            img_info = self.coco.loadImgs(img_id)[0]
            img_path = os.path.join(self.images_path, img_info['file_name'])
            image = Image.open(img_path).resize(TARGET_SIZE)

            # Generate mask for the image
            annIds = self.coco.getAnnIds(imgIds=img_id)
            anns = self.coco.loadAnns(annIds)
            mask = np.zeros((TARGET_SIZE[1], TARGET_SIZE[0]), dtype=np.uint8)
            for ann in anns:
                mask |= self.coco.annToMask(ann).astype(np.uint8)

            batch_images.append(np.array(image) / 255.0)
            batch_masks.append(mask)

        return np.array(batch_images), np.array(batch_masks)


def validate_images_and_masks(generator):
    """
    Validate the shapes and alignment of preprocessed images and masks generated by the provided generator.

    Args:
        generator (CustomDataGenerator): Instance of the CustomDataGenerator class.
    """
    for i in range(len(generator)):
        batch_images, batch_masks = generator[i]

        for image, mask in zip(batch_images, batch_masks):
            if image.shape[:2] != mask.shape[:2]:
                print(f"Mismatch in image and mask dimensions: {image.shape} vs {mask.shape}")
            else:
                print(f"Image and mask dimensions match: {image.shape}")


# Main process
if __name__ == "__main__":
    train_imgIds = filter_images(coco_train, ['person'])
    val_imgIds = filter_images(coco_val, ['person'])
    generate_masks(coco_train, train_imgIds, MASK_DIR_TRAIN, IMAGE_DIR, ['person'])
    generate_masks(coco_val, val_imgIds, MASK_DIR_VAL, IMAGE_DIR, ['person'])
    train_generator = CustomDataGenerator(IMAGE_DIR, MASK_DIR_TRAIN, batch_size=8)
    val_generator = CustomDataGenerator(IMAGE_DIR, MASK_DIR_VAL, batch_size=8)

    validate_images_and_masks(train_generator)
